\documentclass[12pt,a4paper]{article}

\usepackage{graphicx}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage{listings}
\input{solidity-highlighting.tex}
\usepackage{multirow}

\setlength{\parindent}{0em}

\begin{document}

\noindent
\begin{minipage}{120mm}
        {\huge {\bf School of Informatics}}\\
        {\Large {\bf Blockchains and Distributed Ledgers}}\\

        {\Large Assignment 2}\\
        {\normalsize Erodotos Demetriou (s2187344)}
\end{minipage}
\hfill
\begin{minipage}{40mm}              
        \includegraphics[width=40mm]{crest.png}
\end{minipage}

\begin{center}
\rule{\linewidth}{0.5mm}
\end{center}

\section*{Game High-Level Description}
Matching pennies is a zero-sum game used in game theory.
In particular, we have two players who want to bet against each other.
In this game, each player will randomly pick a number 0 or 1 
(we can think of it as true/false or head/tails). 
If both players place the same bet, \emph{playerA} will get the reward of 1 ETH; 
else, if both players choose different numbers \emph{playerB} wis. 
This is a zero-sum game since the reward of the winner is the loss of
the other player. The diagram below illustrates the aforementioned winner/loser
scheme we have described. \\

\begin{table}[htpb]
    \begin{center}
        \begin{tabular}{lccc}
                                                              & \multicolumn{1}{l}{}   & \multicolumn{2}{c}{Player A Bet}                                                \\
                                                              &                        & 0                                      & 1                                      \\ \cline{3-4} 
            \multicolumn{1}{c}{\multirow{2}{*}{Player B Bet}} & \multicolumn{1}{c|}{0} & \multicolumn{1}{c|}{\textit{Player A}} & \multicolumn{1}{c|}{\textit{Player B}} \\ \cline{3-4} 
            \multicolumn{1}{c}{}                              & \multicolumn{1}{c|}{1} & \multicolumn{1}{c|}{\textit{Player B}} & \multicolumn{1}{c|}{\textit{Player A}} \\ \cline{3-4} 
        \end{tabular}
    \end{center}
\end{table}

At any moment, only two players can participate in this game.
They have a specific time limit to complete their round so other
players can play the game later. Each player who wants to join the
game has to bet 1 ETH and pay extra transaction gas fees. \\

It is essential to mention that when a player wants to play, he has to
do this in a two-step process. Firstly, he has to obscure his bet.
This is because any transaction data are visible on public-permissionless blockchains.
For this reason, we use a hash function to locally hash a player's bet
concatenated with a random salt that the player chooses.

\begin{center}
    \[Obscured \; Bet = H( bet || salt ), \;\;\; where \; H: Keccak256Hash\]
\end{center}

Using this technique, when \emph{playerA} submits his bet on the Smart Contract,
nobody can view his real bet value and thus not cheat on him. Afterward,
\emph{playerB} has to place his bet in the same manner. \\

When this phase completes, players' bets are locked, and they can not make
any changes. Subsequently, we move to the second phase of the game, where
each player has to provide his real bet and salt to validate their initial bet inputs. \\

We have to mention that whenever a player interacts with the Smart Contract,
an event is emitted to notify the other player to progress. Each player has
10 minutes to respond, else the one who played last can request a refund and
cancel the game. The player who did not responded in time, loses his ETH, which are kept
by the contract. \\

Finally, any of the two players can call the Smart Contract evaluate function to calculate the winner.
The winner can immediately withdraw his reward from the Smart Contract and reset the game settings
allowing another pair of players to compete. \\

The above process describes the core concept behind the implementation of the game.
Furthermore, during the realization of the program, several programming techniques have
been used to facilitate the flawless and safe execution of the Smart Contract. We discuss
such good programming practices and considerations in the "Potential Hazards and Vulnerabilities" section.\\

There follows a detailed description of each Smart Contract Variables, Functions, and Events: \\

\textbf{\underline{Variables}} \\

\emph{\_playDeadline:} \\

\emph{\_playedLast:} \\

\emph{\_adr\_playerA:} \\

\emph{\_adr\_playerB:} \\

\emph{\_bets:} \\

\emph{Bet:} \\

\emph{\_locked:} \\

\emph{\_playersJoined:} \\

\emph{\_winner:} \\

\emph{giveHiddenBet():} \\

\textbf{\underline{Events}} \\

\emph{event Play:} \\

\emph{event Winner:} \\

\emph{event NewGame:} \\

\textbf{\underline{Functions}} \\

\emph{giveHiddenBet():} \\

\emph{giveRealBet():} \\

\emph{eveluateWinner():} \\

\emph{requestRefund():} \\

\emph{withdraw():} \\

\emph{gameReset:} \\

\section*{Gas Costs Evaluation}
This section measures and evaluates the gas cost we expect to have when deploying and
interacting with the Smart Contract. \\

Gas costs appear in the following table, and they are unquestionably high.
The Smart Contract owner has to pay 1,801,345 gas units to deploy the code, which is
approximately \$995 (price on 26/10/21). This is definitely a high amount of gas which makes the
Smart Contract not so gas efficient. \\

\begin{table}[htpb]
    \begin{center}
        \begin{tabular}{ccc}
        \multicolumn{3}{c}{\textbf{Gas Costs}}                                                                                                                   \\
        \multicolumn{1}{l}{}                                 & \multicolumn{1}{l}{}                            & \multicolumn{1}{l}{}                            \\ \hline
        \multicolumn{3}{|c|}{\textit{\textbf{Contract Owner Fees}}}                                                                                              \\ \hline
        \multicolumn{1}{|c|}{Contract Deployment}            & \multicolumn{2}{c|}{1,798,945}                                                                    \\ \hline
        \multicolumn{1}{l}{}                                 & \multicolumn{1}{l}{}                            & \multicolumn{1}{l}{}                            \\ \hline
        \multicolumn{1}{|c|}{\textit{\textbf{Players Fees}}} & \multicolumn{1}{c|}{\textit{\textbf{Player A}}} & \multicolumn{1}{c|}{\textit{\textbf{Player B}}} \\ \hline
        \multicolumn{1}{|c|}{giveHiddenBet()}                & \multicolumn{1}{c|}{135,643}                    & \multicolumn{1}{c|}{84,620}                     \\ \hline
        \multicolumn{1}{|c|}{giveRealBet()}                  & \multicolumn{1}{c|}{81,007}                     & \multicolumn{1}{c|}{83,807}                     \\ \hline
        \multicolumn{1}{|c|}{evaluate()}                     & \multicolumn{2}{c|}{40,423}                                                                       \\ \hline
        \multicolumn{1}{|c|}{withdraw()}                     & \multicolumn{2}{c|}{43,717}                                                                       \\ \hline
        \multicolumn{1}{|c|}{requestRefund()}                & \multicolumn{2}{c|}{54,648}                                                                       \\ \hline
        \end{tabular}
    \end{center}
\end{table}

In regards to the players interacting with the Smart Contract, the fees are much lower.
Namely, during the initial phase of submitting a hidden bet, \emph{playerA} has to pay 135,643
and \emph{playerB} 84,620 gas units, translating to approximately \$61 and \$44, respectively.
We can notice a considerable difference between the fees paying each player, making this a bit unfair. \\

For the next step, both players need to call the giveRealBet() function, which will cost
them 81,007(\$42) and  83807 (\$43) accordingly. Finally, the evaluation, withdrawal, and
refund functions will cost 40,423(\$20), 43,717(\$20), 54,648(\$28) gas units.  \\

Commenting on the above findings, it is apparent that \emph{playerA} has a disadvantage against \emph{playerB}
in terms of gas fairness. In total, \emph{playerA} has to pay 216,650 gas units while \emph{playerB} 168,427
gas units, occurring a difference of 48,223. To mitigate this imbalance, we propose that \emph{playerB}
call the evaluateWinner() function narrowing the gap to 7800 gas units. Regarding refund
requests and withdrawals, it is more than fair that the transaction invoker pays the proportional
fee for himself.

\begin{itemize}
        \item Techniques to make Smart Contract more fair and cost efficient.
\end{itemize}

\section*{Potential Hazards and Vulnerablities}

Developing a Smart Contract for the Ethereum Network can always be challenging.
This is because, on a public-permissionless blockchain, everything is observable by everyone.
This fact makes it difficult when it comes to securing users' data. Besides that, a developer
has to be alert to write code that is attack-resistant. Ethereum Blockchain and specifically
Smart Contracts expose a broad spectrum of vulnerabilities, enabling an adversarial entity to
exploit them for its interest. \\

When developing the Matching Pennies game, we took into consideration possible attacks.
The following list presents vulnerabilities and mechanisms to moderate them.

\begin{itemize}
        \item List of security mechanisms used to mitigate such hazards
\end{itemize}

\section*{Security vs Performance}
\begin{itemize}
        \item security vs performance trade-offs
\end{itemize}

\section*{Fellow Student Contract Analysis}
\begin{itemize}
        \item Vulnerabilities
        \item How the player can exploit these vulnerabilities and win the game ?
        \item Include code snippets
\end{itemize}

\section*{Smart Contract Execution History}

\section*{Implementation Code}
\begin{lstlisting}
pragma solidity 0.8.0;

/// @title Matching pennies game
/// @author Erodotos Demetriou
contract Game {
    uint256 public _playDeadline;
    address public _playedLast;
    address public _adr_playerA;
    address public _adr_playerB;

    mapping(address => Bet) public _bets;

    struct Bet {
        string _realBet;
        bytes32 _hiddenBet;
        bool _isValid;
    }

    uint8 public _locked = 0;
    uint8 public _playersJoined = 0;
    address public _winner;

    event Play(address indexed _playerAddress, uint8 _playerNumber);
    event WinnerAnnounced(address indexed _winner);
    event NewGame(string _newGame);

    /// @notice Takes 1 ETH as bet stake and set contract state accordingly
    /// @param _bet This is an obscured 32-byte string produced after
    /// hashing (real_bet || salt)
    function giveHiddenBet(bytes32 _bet) public payable {
        // Perform checks
        require(
            _locked == 0,
            "There are already 2 players. Wait for the next game to start!"
        );
        require(msg.value == 1 ether, "You must bet 1 ETH");
        require(
            _bets[msg.sender]._hiddenBet == bytes32(0),
            "You have already put your bet"
        );

        // Change the smart contract state
        _playersJoined += 1;
        _bets[msg.sender]._hiddenBet = _bet;
        _playDeadline = block.timestamp + 10 minutes;
        _playedLast = msg.sender;

        // Lock the contract if both players beted
        // and emmit events to announce their participation
        if (_playersJoined == 2) {
            _locked = 1;
            _adr_playerB = msg.sender;
            emit Play(msg.sender, 2);
        } else {
            _adr_playerA = msg.sender;
            emit Play(msg.sender, 1);
        }
    }

    /// @notice Receives the players real bets 
    /// and their salt and check the initial bet validity
    /// @param _realBet A string representing the real bet
    /// @param _salt The salt that the message sender used
    /// to create his initial obscured bet
    function giveRealBet(string memory _realBet, string memory _salt) external {
        require(_playersJoined == 2, "Wait for player #2 to join the game");
        require(
            keccak256(abi.encodePacked(_realBet, _salt)) ==
                _bets[msg.sender]._hiddenBet,
            "Error: Provided invalid input: Abort"
        );

        _bets[msg.sender]._realBet = _realBet;
        _bets[msg.sender]._isValid = true;

        _playedLast = msg.sender;
        _playDeadline = block.timestamp + 10 minutes;
    }

    /// @notice Calculates the game winner
    function evaluateWinner() external {
        require(
            _bets[_adr_playerA]._isValid && _bets[_adr_playerB]._isValid,
            "Error: Players did not provide their real bet"
        );

        if (
            keccak256(abi.encode(_bets[_adr_playerA]._realBet)) ==
            keccak256(abi.encode(_bets[_adr_playerA]._realBet))
        ) {
            _winner = _adr_playerA;
        } else if (
            keccak256(abi.encode(_bets[_adr_playerA]._realBet)) !=
            keccak256(abi.encode(_bets[_adr_playerA]._realBet))
        ) {
            _winner = _adr_playerB;
        }

        // Emit event
        emit WinnerAnnounced(_winner);
    }

    /// @notice Let a player to stop the game and get 
    /// refund in case his opponent griefs
    function requestRefund() external {
        // Checks
        require(
            block.timestamp > _playDeadline &&
                msg.sender == _playedLast &&
                _winner == address(0),
            "You are not allowed  to request a refund yet!"
        );

        gameReset();
    }

    /// @notice Allows the winner to withdraw his reward
    function withdraw() external {
        // Checks
        require(msg.sender == _winner, "You are not the winner!");

        gameReset();
    }

    /// @notice Send money to the winner or the 
    /// refund requestor and reset game variables for a new round
    function gameReset() internal {
        _locked = 0;
        _winner = address(0);
        _playersJoined = 0;
        _bets[_adr_playerA] = Bet("", bytes32(0), false);
        _bets[_adr_playerB] = Bet("", bytes32(0), false);
        _adr_playerA = address(0);
        _adr_playerB = address(0);
        _playDeadline = 0;

        // Reward/Refund transfer
        (bool success, ) = msg.sender.call{value: 2 ether}("");
        require(success, "Error: Withdraw unsuccessful");

        // Emmit event
        emit NewGame("New game spots available");
    }
}
\end{lstlisting}

\end{document}